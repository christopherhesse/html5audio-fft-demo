// Generated by IcedCoffeeScript 1.3.3h
(function() {
  var KEY_WIDTH, NOTES, SPECTROGRAM_ROWS, SPECTROGRAM_ROW_HEIGHT, UPDATE_PERIOD, clear_canvas, convert_to_note_magnitudes, create_context, gen_freq_bins, gen_notes, generate_key_widths, get_note_magnitudes, load_audio, main, set_interval, set_timeout, setup_keyboard, setup_spectrogram,
    __slice = [].slice;

  window.iced = {
    Deferrals: (function() {

      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) return this.continuation(this.ret);
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  window.__iced_k = window.__iced_k_noop = function() {};

  UPDATE_PERIOD = 50;

  SPECTROGRAM_ROWS = 20;

  SPECTROGRAM_ROW_HEIGHT = 5;

  KEY_WIDTH = 20;

  set_timeout = function(timeout, f) {
    return setTimeout(f, timeout);
  };

  set_interval = function(timeout, f) {
    return setInterval(f, timeout);
  };

  gen_notes = function() {
    var freq, name, name_index, names, note, notes, octave, white;
    names = ["A", "A#/Bb", "B", "C", "C#/Db", "D", "D#/Eb", "E", "F", "F#/Gb", "G", "G#/Ab"];
    freq = 27.5000;
    name_index = 0;
    octave = 0;
    notes = [];
    while (freq < 4186.1) {
      name = names[name_index];
      white = name.indexOf("/") === -1;
      note = {
        name: name,
        octave: octave,
        freq: freq,
        white: white
      };
      notes.push(note);
      name_index = (name_index + 1) % names.length;
      freq = freq * Math.pow(2, 1 / 12);
      if (names[name_index] === "C") octave += 1;
    }
    return notes;
  };

  NOTES = gen_notes();

  gen_freq_bins = function(sampleRate, frequencyBinCount, fftSize) {
    var freqBins;
    freqBins = [0];
    while (freqBins.length < frequencyBinCount) {
      freqBins.push(_.last(freqBins) + sampleRate / fftSize);
    }
    return freqBins;
  };

  convert_to_note_magnitudes = function(freqData, freqBins) {
    var freq, index, lowerFreq, lowerMagnitude, magnitude, magnitudes, note, slope, upperFreq, upperMagnitude, _i, _j, _len, _len1;
    magnitudes = [];
    for (_i = 0, _len = NOTES.length; _i < _len; _i++) {
      note = NOTES[_i];
      for (index = _j = 0, _len1 = freqBins.length; _j < _len1; index = ++_j) {
        freq = freqBins[index];
        if (freq > note.freq) break;
      }
      lowerFreq = freqBins[index - 1];
      upperFreq = freq;
      lowerMagnitude = freqData[index - 1];
      upperMagnitude = freqData[index];
      slope = (upperMagnitude - lowerMagnitude) / (upperFreq - lowerFreq);
      magnitude = slope * (note.freq - lowerFreq) + lowerMagnitude;
      magnitudes.push(magnitude);
    }
    return magnitudes;
  };

  create_context = function(width, height) {
    var $canvas, canvas, canvas_elem;
    $canvas = $("<canvas></canvas>");
    $(document.body).append($canvas);
    canvas_elem = $canvas[0];
    canvas_elem.width = width;
    canvas_elem.height = height;
    canvas = canvas_elem.getContext("2d");
    canvas.elem = canvas_elem;
    return canvas;
  };

  clear_canvas = function(canvas) {
    return canvas.clearRect(0, 0, canvas.elem.width, canvas.elem.height);
  };

  generate_key_widths = function() {
    var index, keyWidths, lastNote, nextNote, note, width, _i, _len;
    keyWidths = [];
    for (index = _i = 0, _len = NOTES.length; _i < _len; index = ++_i) {
      note = NOTES[index];
      lastNote = NOTES[index - 1];
      nextNote = NOTES[index + 1];
      if (note.white) {
        width = KEY_WIDTH;
        if ((lastNote != null) && !lastNote.white) width -= KEY_WIDTH / 4;
        if ((nextNote != null) && !nextNote.white) width -= KEY_WIDTH / 4;
      } else {
        width = KEY_WIDTH / 2;
      }
      keyWidths.push(width);
    }
    return keyWidths;
  };

  get_note_magnitudes = function(analyser, freqBins) {
    var freqByteData, freqData, m, magnitudes, point;
    freqByteData = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(freqByteData);
    freqData = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = freqByteData.length; _i < _len; _i++) {
        point = freqByteData[_i];
        _results.push(point / 255);
      }
      return _results;
    })();
    magnitudes = convert_to_note_magnitudes(freqData, freqBins);
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = magnitudes.length; _i < _len; _i++) {
        m = magnitudes[_i];
        _results.push(Math.pow(m, 4));
      }
      return _results;
    })();
  };

  setup_spectrogram = function(analyser) {
    var draw_spectrogram, freqBins, keyWidths, spectrogram, stored_magnitudes;
    spectrogram = create_context(NOTES.length * KEY_WIDTH + 1, SPECTROGRAM_ROW_HEIGHT * SPECTROGRAM_ROWS);
    keyWidths = generate_key_widths();
    freqBins = gen_freq_bins(window.audio.sampleRate, analyser.frequencyBinCount, analyser.fftSize);
    stored_magnitudes = [];
    set_interval(UPDATE_PERIOD, function() {
      var magnitudes;
      magnitudes = get_note_magnitudes(analyser, freqBins);
      stored_magnitudes.push(magnitudes);
      return draw_spectrogram();
    });
    return draw_spectrogram = function() {
      var index, magnitude, magnitudes, note, redness, row, width, x_offset, y_offset, _i, _j, _len, _len1, _ref, _results;
      clear_canvas(spectrogram);
      if (stored_magnitudes.length < SPECTROGRAM_ROWS) {
        row = stored_magnitudes.length;
      } else {
        row = SPECTROGRAM_ROWS;
      }
      _ref = stored_magnitudes.slice(-SPECTROGRAM_ROWS);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        magnitudes = _ref[_i];
        y_offset = row * SPECTROGRAM_ROW_HEIGHT;
        x_offset = 0;
        for (index = _j = 0, _len1 = NOTES.length; _j < _len1; index = ++_j) {
          note = NOTES[index];
          width = keyWidths[index];
          magnitude = magnitudes[index];
          redness = Math.round(magnitude * 255);
          spectrogram.fillStyle = "rgb(255," + (255 - redness) + "," + (255 - redness) + ")";
          spectrogram.fillRect(x_offset, y_offset, width, SPECTROGRAM_ROW_HEIGHT);
          x_offset += width;
        }
        _results.push(row -= 1);
      }
      return _results;
    };
  };

  setup_keyboard = function(analyser) {
    var draw_keyboard, freqBins, keyHeight, keyWidths, keyboard;
    keyHeight = KEY_WIDTH * 4;
    keyboard = create_context(52 * KEY_WIDTH + 1, keyHeight * 1.5);
    keyWidths = generate_key_widths();
    freqBins = gen_freq_bins(window.audio.sampleRate, analyser.frequencyBinCount, analyser.fftSize);
    draw_keyboard = function() {
      var index, magnitude, magnitudes, note, offset, redness, _i, _j, _len, _len1, _results;
      magnitudes = get_note_magnitudes(analyser, freqBins);
      clear_canvas(keyboard);
      offset = 0;
      for (index = _i = 0, _len = NOTES.length; _i < _len; index = ++_i) {
        note = NOTES[index];
        if (note.white) {
          keyboard.fillStyle = "rgb(0,0,0)";
          keyboard.fillRect(offset, 0, KEY_WIDTH + 1, keyHeight);
          magnitude = magnitudes[index];
          redness = Math.round(magnitude * 255);
          keyboard.fillStyle = "rgb(255," + (255 - redness) + "," + (255 - redness) + ")";
          keyboard.fillRect(offset + 1, 1, KEY_WIDTH - 1, keyHeight - 2);
          offset += KEY_WIDTH;
        }
      }
      offset = 0;
      _results = [];
      for (index = _j = 0, _len1 = NOTES.length; _j < _len1; index = ++_j) {
        note = NOTES[index];
        if (note.white) {
          _results.push(offset += KEY_WIDTH);
        } else {
          magnitude = magnitudes[index];
          redness = Math.round(magnitude * 255);
          keyboard.fillStyle = "rgb(" + redness + ",0,0)";
          _results.push(keyboard.fillRect(offset - KEY_WIDTH * 0.25, 0, KEY_WIDTH / 2, keyHeight * 0.6));
        }
      }
      return _results;
    };
    return draw_keyboard;
  };

  main = function() {
    var delay, delayTime, draw, draw_keyboard, keyboardAnalyser, response, spectrumAnalyser, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    window.audio = new webkitAudioContext();
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "main.iced",
        funcname: "main"
      });
      load_audio("/glasswindow.wav", __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return response = arguments[0];
          };
        })(),
        lineno: 191
      }));
      __iced_deferrals._fulfill();
    })(function() {
      window.source = audio.createBufferSource();
      source.buffer = audio.createBuffer(response, false);
      spectrumAnalyser = audio.createAnalyser();
      spectrumAnalyser.fftSize = 2048;
      spectrumAnalyser.smoothingTimeConstant = 0;
      source.connect(spectrumAnalyser);
      delayTime = UPDATE_PERIOD / 1000 * SPECTROGRAM_ROWS;
      delay = audio.createDelay(delayTime);
      delay.delayTime.value = delayTime;
      source.connect(delay);
      delay.connect(audio.destination);
      keyboardAnalyser = audio.createAnalyser();
      keyboardAnalyser.fftSize = 2048;
      keyboardAnalyser.smoothingTimeConstant = 0.2;
      delay.connect(keyboardAnalyser);
      setup_spectrogram(spectrumAnalyser);
      draw_keyboard = setup_keyboard(keyboardAnalyser);
      draw = function() {
        window.requestAnimationFrame(draw);
        return draw_keyboard();
      };
      window.start = function() {
        window.requestAnimationFrame(draw);
        return source.start(0);
      };
      window.stop = function() {
        return source.stop(0);
      };
      return window.start();
    });
  };

  load_audio = function(url, cb) {
    var request;
    request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "arraybuffer";
    request.onload = function() {
      return cb(request.response);
    };
    return request.send();
  };

  $(document).ready(function() {
    return main();
  });

}).call(this);
